# Technical Documentation — HBnB

**Version**: 1.0  
**Contents**: diagrams (package, class, sequence), explanatory notes, design decisions, and delivery instructions.

---

## Introduction

This document consolidates the diagrams and explanatory notes required to understand the architecture and behavior of the **HBnB** application.  
It serves as a technical blueprint for implementation and maintenance. The document covers:

- Package diagram (high-level view)
- Detailed class diagram for the Business Logic layer
- Sequence diagrams for four key API calls
- Explanatory notes and design decisions

---

## 1. High-Level Architecture (Package Diagram)

The system is structured into three main layers: **Presentation**, **Business Logic**, **Persistence**.  
Below is a Mermaid representation of the package/architecture:

```mermaid
classDiagram
    class PresentationLayer {
        <<Package>>
        +Services
        +API Endpoints
    }

    class BusinessLogicLayer {
        <<Package>>
        +User
        +Place
        +Review
        +Amenity
    }

    class PersistenceLayer {
        <<Package>>
        +Database access objects
        +Repositories
    }

    PresentationLayer --> BusinessLogicLayer : Facade Pattern
    BusinessLogicLayer --> PersistenceLayer : CRUD operations
```

**Purpose of the diagram**: to show separation of responsibilities and dependency flow (Presentation depends on Business Logic, Business Logic depends on Persistence).

**Design decisions**:
- Strict separation: controllers never access the database directly.
- Services / Use Cases centralize business logic, improving testability.
- Repositories encapsulate data access (ORM/SQL), allowing flexibility and easier testing.

---

## 2. Class Diagram — Business Logic Layer

The diagram below describes the main entities and their relationships: `BaseModel`, `User`, `Place`, `Review`, `City`, `Amenity`, along with the services and repositories.

```mermaid
classDiagram
    class UserEntity {
        -ID: UUID4
        -Admin: bool
        -first name: str
        -last name: str
        -email: str
        -password: str
        +register()
        +update()
        +deleted()
    }
    UserEntity "1" <|-- "0..*" Owner
    class Owner {
        +listedplace()
    }
    Owner "1" *-- "0..*" PlaceEntity : create
    class PlaceEntity {
        -ID: UUID4
        -title: str
        -description: str
        -price: float
        -latitude: float
        -longitude: float
        +create()
        +update()
        +delete()
    }
    PlaceEntity "1" *-- "0..*" AmenityEntity
    class AmenityEntity {
        -ID: UUID4
        -name: str
        -description: str
        +create()
        +update()
        +delete()
    }
    UserEntity "1"<|-- "2" Administrator : Valentin Loïc
    Administrator -- UserClient
    Administrator -- Owner
    Administrator -- ReviewEntity
    Administrator -- PlaceEntity
    Administrator -- AmenityEntity
    class Administrator {
        +modify*()
    }
    UserEntity "1" <|-- "0..*" UserClient
    class UserClient {
        -cardinfo: str
    }
    UserClient "1" *-- "0..1"ReviewEntity : write
    ReviewEntity -- "1" PlaceEntity
    class ReviewEntity {
        +id: UUID
        +rating: int
        +comment: str
        +created_at: datetime
        +updated_at: datetime
        +create()
        +delete()
    }
```

**Explanation**:
- `BaseModel` provides common fields and behavior (id, timestamps, basic CRUD).
- Entities `User`, `Place`, `Review` inherit from `BaseModel`.
- Services (`UserService`, `PlaceService`, `ReviewService`) orchestrate business logic: validations, rules, transactions.
- Repositories encapsulate access to the database.

**Design choices**:
- Services maintain lightweight controllers (single responsibility).
- Repositories return domain objects (`Place`, `User`, etc.) rather than raw dicts for consistency.
- Domain logic (e.g., `calculate_rating`) resides in services or models depending on complexity.

---

## 3. Sequence Diagrams for API Calls

The following diagrams show the interaction flow between User (client), API (controllers), Business Logic (services/models), and Persistence (repositories/database).

### 3.1 User Registration

```mermaid
sequenceDiagram
    participant User
    participant API
    participant BusinessLogic as UserModel
    participant Database

    User->>API: POST /users (email, password, etc.)
    API->>BusinessLogic: validate_input(data)
    BusinessLogic->>Database: INSERT new user
    Database-->>BusinessLogic: success
    BusinessLogic-->>API: user_created_response
    API-->>User: 201 Created (user_id, token)
```

**Notes**:
- Check email uniqueness (`find_by_email`) before creating.
- Hash password in `UserService` before saving.
- Return token (JWT) if required by the spec.

---

### 3.2 Place Creation

```mermaid
sequenceDiagram
    participant User
    participant API
    participant BusinessLogic as PlaceModel
    participant Database

    User->>API: POST /places (title, description, price, etc.)
    API->>BusinessLogic: validate_and_build_place(data, user_id)
    BusinessLogic->>Database: INSERT new place
    Database-->>BusinessLogic: success
    BusinessLogic-->>API: place_created_response
    API-->>User: 201 Created (place_id)
```

**Notes**:
- Validate ownership (the user can create a place).
- Handle relationships (city_id, amenities) in the transaction.

---

### 3.3 Review Submission

```mermaid
sequenceDiagram
    participant User
    participant API
    participant BusinessLogic as ReviewModel
    participant Database

    User->>API: POST /places/{id}/reviews (rating, comment)
    API->>BusinessLogic: validate_and_build_review(data, user_id, place_id)
    BusinessLogic->>Database: INSERT new review
    Database-->>BusinessLogic: success
    BusinessLogic-->>API: review_created_response
    API-->>User: 201 Created (review_id)
```

**Notes**:
- Ensure user is allowed to post a review (e.g., only after booking).
- After saving, recalculate and update the place’s average rating.

---

### 3.4 Fetch Places

```mermaid
sequenceDiagram
    participant User
    participant API
    participant BusinessLogic as PlaceService
    participant Database

    User->>API: GET /places?city=Paris&max_price=100
    API->>BusinessLogic: fetch_places(filters)
    BusinessLogic->>Database: SELECT * FROM places WHERE filters
    Database-->>BusinessLogic: list_of_places
    BusinessLogic-->>API: places_response(list_of_places)
    API-->>User: 200 OK (JSON list of places)
```

**Notes**:
- Pagination and limits recommended (`page`, `per_page`).
- Sanitize/filter inputs (prevent injection).
- Option: cache results for frequent queries.

---

## 4. Explanatory Notes and Design Decisions

### 4.1 Layered separation
- **Presentation (API)**: routes, auth, request/response handling.
- **Business Logic (Services/Models)**: rules, validations, orchestrations.
- **Persistence (Repositories/Database)**: transactions and data access.

Reason: maintainability, testability, easier evolution.

### 4.2 Transactions and consistency
- Multi-table operations (e.g., place + amenities) must run in atomic transactions.
- Services coordinate transactions (or delegate to ORM).

### 4.3 Validation and security
- Validate at API (format) and Service (business rules).
- Password hashing with bcrypt/argon2.
- JWT/sessions for authentication; verify roles/scopes.

### 4.4 Performance
- Use pagination, indexing on frequent queries (city_id, price).
- Possible caching with Redis.

---

## 5. Deliverables and Repo Structure

**Files to include in repo `holbertonschool-hbnb/part1`:**
- `docs/hbnb_technical_documentation.md` (this document)
- `docs/diagrams/package_diagram.mmd` (Mermaid, optional)
- `docs/diagrams/class_diagram.mmd`
- `docs/diagrams/sequence_diagrams.mmd`

**Commit suggestion (example)**:
```bash
cd holbertonschool-hbnb/part1
git checkout -b docs/technical-documentation
mkdir -p docs/diagrams
# copy docs/... files here
git add docs/hbnb_technical_documentation.md docs/diagrams/*
git commit -m "docs: technical documentation — architecture, class and sequence diagrams"
git push -u origin docs/technical-documentation
```

**Export to PDF** (optional):  
Use pandoc + wkhtmltopdf, or export from your editor (VS Code -> Print to PDF).
```bash
pandoc docs/hbnb_technical_documentation.md -o docs/hbnb_technical_documentation.pdf --pdf-engine=wkhtmltopdf
```
Note: Mermaid diagrams may not render automatically in PDF — render to HTML first, then export to PDF via browser.

---

## 6. Next Steps (recommended)
1. Review this document with your team/tutor.  
2. Add sample payloads (JSON requests/responses) for each API.  
3. Generate diagrams as PNG/SVG if needed for PDF inclusion.  
4. Write integration tests for critical flows (user registration, place creation, reviews).

---
